<!DOCTYPE html>
<html lang='en' xml:lang='en' xmlns='http://www.w3.org/1999/xhtml'>
  <head>
    <meta content='text/html;charset=UTF-8' http-equiv='content-type'>
    <title>Phylogram </title>
	
    <script src="http://d3js.org/d3.v3.min.js" type="text/javascript"></script>
	
    <script>
    var reader = new FileReader();
	
	/******************************************************************************************************
	* •	Read an input file through line by line
	* •	To estimate the proportion of differences, divide the number of differences by the total number of nucleotides examined
	******************************************************************************************************/

	function readText(that, upgma, nj, rec, rad, tf, pwm, pwp, gsize){
	
		if(gsize > 1){

		if(that.files && that.files[0]){
		
			var names= [];
			
			var reader = new FileReader();
			
			var nnm=0;
			
			reader.onload = function (e) { 
			
				var output=e.target.result;
			
				var y=output.split("\n");
				
				var mut=new Array(500);
				
				var all=new Array(500);
			
				for(var i=0; i<500;i++){
			
					mut[i]=new Array(500);
					
					all[i]=new Array(500);
				
					for(var j=0; j<500;j++){
				
						mut[i][j]=0;
						
						all[i][j]=0;
					
					}
				
				}
				
				for(var i=0; i<y.length; i++){
				
					var x=y[i].split("\t");
					
					var ex = x[0].match(/#/);
				
					if(ex){
					
						if(x[0] === "#CHROM"){
					
							nnm = 9;
							
							while(x[nnm]){
							
								names[nnm-9]=x[nnm];
								
								nnm++;
						
							}
						
						}
					
					}
					
					else{
					
						if(i == 0){
						
							alert("Error - This is not a VCF file");
						
						}
					
						for(var p = 9; p < nnm; p++){
						
							var str1="";
							
							var xx="";
							
							if(x[p]){
							
								xx=x[p].split(":");
								
							}
					
							if(xx[0] === "0/0" || xx[0] === "0|0"){
						
								str1="00";
							}
						
							else if(xx[0] === "1/0" || xx[0] === "0/1" || xx[0] === "1|0" || xx[0] === "0|1"){
						
								str1="01";
							}
							
							else if(xx[0] === "1/1" || xx[0] === "1|1"){
						
								str1="11";
							}
						
							for(var q = 9; q < nnm; q++){
						
								var str2="";
								
								var yy="";
							
								if(x[q]){
							
									yy=x[q].split(":");
								
								}
					
								if(yy[0] === "0/0" || yy[0] === "0|0"){
						
									str2="00";
								}
						
								else if(yy[0] === "1/0" || yy[0] === "0/1" || yy[0] === "1|0" || yy[0] === "0|1"){
						
									str2="01";
								}
							
								else if(yy[0] === "1/1" || yy[0] === "1|1"){
						
									str2="11";
								}
							
								if((str1 === "00" || str1 === "01" || str1 === "11") && (str2 === "00" || str2 === "01" || str2 === "11")){
							
									
									if((str1 === "00" && str2 === "01") || (str1 === "01" && str2 === "00")){
									
										mut[p-9][q-9] = mut[p-9][q-9]+1;
						
									}
									
									if((str1 === "00" && str2 === "11") || (str1 === "11" && str2 === "00")){
									
										mut[p-9][q-9] = mut[p-9][q-9]+1;
						
									}
								
									all[p-9][q-9] = all[p-9][q-9]+1;
									
								}								
								
							}
							
						}
						
					}
					
				}
				
				nnm=nnm-9;
				
				for(var p = 0; p < nnm; p++){
				
					for(var q = 0; q < nnm; q++){
					
						mut[p][q] = mut[p][q]/gsize;
						
					}
					
				}
				
				if(pwm){
				
					var dd = displayPwd(mut,nnm,names,"1");
				
				}
				
				else if(pwp){
				
					var dd = displayPwd(mut,nnm,names,"2");
				
				}
				
				else{
				
					if(rec){
				
						var opt=1;
				
					}
				
					else if(rad){
				
						var opt=2;
				
					}
					
					if(upgma){
					
						var upg =1;
						
					}
					
					else if(nj){
					
						var upg =2;
					
					}
					
					var aa = phytree(upg, nnm, mut, names, opt, tf);
					
				}
				
			};
			
			reader.readAsText(that.files[0]);
			
		}
		
		else{
		
			alert("Cannot read the VCF file");
		
		}
		
		}
		
		else{
		
			alert("Enter a valid genome size");
		
		}
		
		
	} 
	
	/**********************************************************************
	* Go back to the index page
	**********************************************************************/
	
	function goBack() {
    
    	location.reload();
    	
	}
	
	
	
	/*********************************************************************************
	* the section calls all functions to construct a phylogenetic tree based on the Neighbor-Joining algorithm using the pairwise divergence matrix. 
	*********************************************************************************/
	
	function phytree(upgt, popnum, pa, popname, types, trfl){
	
		var topo
	
		var u;
	
		var v;
		
		if(upgt == 1){
		
			for(var nums=popnum; nums > 1; nums--){
	
				var mini = minimal_upg(nums,pa);
				
				var popname= nms_upg(mini, nums, pa, popname);
				
				var pr1 = 0;
				
				var pr2 = 0;
				
				var pn = popname[0];
				
				if(pn){
				
					var xnum = pn.split(")");
					
					pr1 = xnum.length;
					
				}
				
				var pn = popname[1];
				
				if(pn){
				
					var ynum = pn.split(")");
					
					pr2 = ynum.length;
					
				}
		
				var pa = neighbour_upg(mini, nums, pr1, pr2, pa);
		
				if(nums == 2){
				
					topo=popname[0]+";";
					
					if(trfl){
				
						var tre = treeFile(topo);
					
					}
				
					else{
				
						var display = load(topo, popnum, types);
					
					}
				
				}
				
			}
			
		}
		
		else{
	
			for(var nums=popnum; nums > 2; nums--){
	
				var mini = minimal(nums,pa);
		
				var brc = bl(mini, nums, pa);
			
				var popname= nms(brc, mini, nums, pa, popname);
		
				var pa = neighbour(mini, nums, pa);
		
				var blen=blen+brc+",";
			
				if(nums == 3){
				
					topo="("+popname[0]+","+popname[1]+":"+pa[1][0]+");";
				
					if(trfl){
					
						var tre = treeFile(topo);
					
					}
				
					else{
				
						var display = load(topo, popnum, types);
					
					}
				
				}
			
			}
			
		}
		
	}
	
	/**********************************************************************
	* Minimal function will identify the neighbouring pair of individuals using the Q-matrix to 
	identify the phylogenetic relationship between populations or between individuals.
	**********************************************************************/
	
	function minimal(n,pap){
	
		var min = 1000000;
		
		var row=[];
		
		var ele;
		
		for( var p = 0; p < n; p++){
		
			var sum=0;
		
			for( var q = 0; q < n; q++){
		
				sum=sum+pap[p][q];

			}
			
			row[p]=sum

		}
		
		for( var p = 0; p < n; p++){
		
			for( var q = 0; q < n; q++){
			
				sum=((n-2)*pap[p][q])-row[p]-row[q];
				
				if(p != q){
				
					if(sum < min){
					
						min=sum;
						
						ele=p+","+q;
					
					}
					
				}
			
			}
			
		}
		
		return ele;
	
	}
	
	function minimal_upg(n,pap){
	
		var min = 1000000;
		
		var ele;
		
		for( var p = 0; p < n; p++){
		
			for( var q = 0; q < n; q++){
			
				if(p != q){
				
					if(pap[p][q] < min){
					
						min=pap[p][q];
						
						ele=p+","+q+","+min;
					
					}
					
				}
			
			}
			
		}
		
		return ele;
	
	}
	
	/**********************************************************************
	* Function bl will estimate the distance from member pair to the new node 
	**********************************************************************/

	function bl(mn, spp, pap2){
	
		var row2 = [];
		
		var a;
		
		var b;
		
		var br1;
		
		var br2;
		
		var ret2;
		
		var nr = new Array(spp);
		
		for(var x = 0; x < spp; x++){
			
			nr[x] = new Array(spp);
				
			for(var y = 0; y < spp; y++){
				
				nr[x][y]=0;
					
			}
				
		}	
	
	
		for(var x = 0; x < spp; x++){
		
			var sum2=0;
			
			for(var y = 0; y < spp; y++){
			
				nr[x][y]= pap2[x][y];
				
				sum2=sum2+pap2[x][y];
				
			}
			
			row2[x]=sum2;

		}
		
		var s = mn.split(',');
		
		a=s[0];
		
		b=s[1];
		
		br1 = ((1/2)*nr[a][b])+((1/(2*(spp-2)))*(row2[a]-row2[b]));
		
		br2 = nr[a][b]-br1;
		
		ret2=br1+","+br2;
		
		return ret2;

	}
	
	/**********************************************************************
	* The computational clusters and the names of the individuals in each branch will be associated in the function nms
	**********************************************************************/
	
	function nms(bln,mn3,spp3,pap3,name){
	
		var nm=[];
		
		var c=mn3.split(",");
		
		var st1=c[0];
		
		var st2=c[1];
		
		var d = bln.split(",");
		
		nm[0]="("+name[st1]+":"+d[0]+","+name[st2]+":"+d[1]+")";
		
		var l=1;
		
		var k=1;
		
		for(r = 0 ;r < spp3; r++){
		
			var flag=0;
		
			for(s = 0 ;s < spp3; s++){
			
				if(st1 != r && st2 != r && st1 != s && st2 != s){
				
					nm[k]=name[r];
					
					flag=1;
					
					l++;

				}
			
			}
			
			if(flag == 1){
			
				k++;
				
				l=1;
				
			}
			
		}
		
		return nm;
	
	}
	

	function nms_upg(mn3,spp3,pap3,name){
	
		var nm=[];
		
		var c=mn3.split(",");
		
		var d1 = c[2]/2;
		var d2 = c[2]/2;
		
		var t1 = c[0];
		var tmp1 = name[t1];
		var qq = tmp1.split(",");
		
		var ln1 = qq.length;
		
		var tmp2 = qq[ln1-1];
		
		var qqq = tmp2.split(":");
		
		var ln2 = qqq.length;
		
		var intnd=0;
	
		for(var jj=1;jj < ln2; jj++){
		
			var tmp3 = qqq[jj];
			
			if(tmp3){
			
				var tmp4 = tmp3.split(")");
				
				intnd=intnd+parseFloat(tmp4[0]);
				
			}
			
		}
	
		d1 = d1 - intnd;
		
		var t2 = c[1];
	
		var tmp1 = name[t2];
		
		var qq = tmp1.split(",");
		
		var ln1 = qq.length;
	
		var tmp2 = qq[ln1-1];
		
		var qqq = tmp2.split(":");
		
		var ln2 = qqq.length;
		
		var intnd=0;
	
		for(var jj=1;jj < ln2; jj++){
		
			var tmp3 = qqq[jj];
			
			if(tmp3){
			
				var tmp4 = tmp3.split(")");
			
				intnd=intnd+parseFloat(tmp4[0]);
				
			}
			
		}
	
		d2 = d2 - intnd;
		
		nm[0]="("+name[t1]+":"+d1+","+name[t2]+":"+d2+")";
		
		var l=1;
		
		var k=1;
		
		for(r = 0 ;r < spp3; r++){
		
			var flag=0;
		
			for(s = 0 ;s < spp3; s++){
			
				if(t1 != r && t2 != r && t1 != s && t2 != s){
				
					nm[k]=name[r];
					
					flag=1;
					
					l++;

				}
			
			}
			
			if(flag == 1){
			
				k++;
				
				l=1;
				
			}
			
		}
		
		return nm;
	
	}
	
	
	
	/**********************************************************************
	* At each iteration of the algorithm, the distance matrix is reduced by one column and one row in the function neighbour
	**********************************************************************/
		
	function neighbour(mn4,spp4,pap4){
	
		var z;
		
		var nr4 = new Array(spp4);
		
		var nrr = new Array(spp4);
	
		for(var m = 0; m < spp4; m++){
				
			nr4[m] = new Array(spp4);
			
			nrr[m] = new Array(spp4);
					
			for(var n = 0; n < spp4; n++){
					
				nr4[m][n]=0;
				
				nrr[m][n]=0;
						
			}
		}	
	
		for(var m = 0; m < spp4; m++){
		
			for(var n = 0; n < spp4; n++){
			
				nr4[m][n] = pap4[m][n];
				
			}
		}
		
		var f=mn4.split(",");
		
		var str1=f[0];
		
		var str2=f[1];
		
		var g=1;
		
		var h=0;
		
		for(var m=0;m<spp4;m++){
		
			if(m != str1 && m != str2){
			
				z = ((nr4[str1][m]+nr4[str2][m])-nr4[str1][str2])/2;
				
				nrr[0][g]=z;
				
				nrr[g][0]=z;
				
				g++;	
				
			}

		}
		
		g=1;

		h=1;
		
		for(var m=0;m<spp4;m++){
		
			fl=0;
		
			for(var n=0;n<spp4;n++){
			
				if(str1 != m && str2 != m && str1 != n && str2 != n){
				
					nrr[g][h]=nr4[m][n];
					
					fl=1;
					
					h++;

				}
				
			}
			
			if(fl ==1){
			
				g++;
				
				h=1;

			}
			
		}
		
		return nrr;

	}
	
	function neighbour_upg(mn4,spp4,prr1, prr2, pap4){
	
		var z;
		
		var nr4 = new Array(spp4);
		
		var nrr = new Array(spp4);
	
		for(var m = 0; m < spp4; m++){
				
			nr4[m] = new Array(spp4);
			
			nrr[m] = new Array(spp4);
					
			for(var n = 0; n < spp4; n++){
					
				nr4[m][n]=0;
				
				nrr[m][n]=0;
						
			}
		}	
	
		for(var m = 0; m < spp4; m++){
		
			for(var n = 0; n < spp4; n++){
			
				nr4[m][n] = pap4[m][n];
				
			}
		}
		
		var f=mn4.split(",");
		
		var str1=f[0];
		
		var str2=f[1];
		
		var g=1;
		
		var h=0;
		
		for(var m=0;m<spp4;m++){
		
			if(m != str1 && m != str2){
			
				z = ((nr4[str1][m]*prr1)+(nr4[str2][m]*prr2))/(prr1+prr2);
				
				nrr[0][g]=z;
				
				nrr[g][0]=z;
				
				g++;	
				
			}

		}
		
		g=1;

		h=1;
		
		for(var m=0;m<spp4;m++){
		
			fl=0;
		
			for(var n=0;n<spp4;n++){
			
				if(str1 != m && str2 != m && str1 != n && str2 != n){
				
					nrr[g][h]=nr4[m][n];
					
					fl=1;
					
					h++;

				}
				
			}
			
			if(fl ==1){
			
				g++;
				
				h=1;

			}
			
		}
		
		return nrr;

	}
	
	/**********************************************************************
	* This section is responsibile for displaying the results
	**********************************************************************/
	
	function load(tree,populations,drawtypes) {
    
    	var newicks = nw(tree);
    	
    	if(drawtypes == 1){
        
			var w=500;
       	 
			var h=populations*50;
       
			d3.phylogram.build('#phylogram', newicks, {
       	 
				width: w,
         	 
				height: h
         	 
        	});
        	
       	}
       	
       	if(drawtypes == 2){
        
			var w=450+populations*5;
       	 
			var h=450+populations*5;
       
			d3.phylogram.buildRadial('#phylogram', newicks, {
       	 
				width: w,
         	 
				height: h
         	 
        	});
        	
       	}
        
    }
	
	/**********************************************************************
	* Newick formatted phylogenetic information will be converted in a new JSON format in nw function
	**********************************************************************/
      
	function nw(tre) {
	
    	var anc = [];
    	
   	 	var tr = {};
   	 	
   	 	var tok = tre.split(/\s*(;|\(|\)|,|:)\s*/);
   	 	
    	for (var i=0; i<tok.length; i++) {
    	
     		var toks = tok[i];
     		
      		switch (toks) {
      		
        		case '(': 
        		
					var stre = {};
          		
					tr.branchset = [stre];
          		
					anc.push(tr);
          		
					tr = stre;
          		
					break;
        
				case ',': 
				
					var stre = {};
					
					anc[anc.length-1].branchset.push(stre);
					
					tr = stre;
					
					break;
				
				case ')': 
				
					tr = anc.pop();
					
					break;
				
				case ':': 
				
					break;
				
				default:
				
					var x = tok[i-1];
					
					if (x == ')' || x == '(' || x == ',') {
						
							tr.name = toks;
							
					}

					else if (x == ':') {
						
							tr.length = parseFloat(toks);
							
						}
						
					}
					
				}
    	
    	return tr;
    	
  	};
	
	/**********************************************************************
	* displayPwd will display the pairwise distances 
	**********************************************************************/
	
	function displayPwd(pw,tot,lbls,format){
	
		if(format == 1){
	
			var nmss="#MEGA\n !Title=;\n\n";
		
			for(var i = 0; i < tot; i++){
		
				nmss=nmss+"#"+lbls[i]+"\n";
			
			}
		
			nmss=nmss+"\n";
			
		}
		
		else if(format == 2){
		
			var phy=tot+"\n";
			
		}
	
		var str="";
		
		var str1="[\t";
	
		for(var i = 0; i < tot; i++){
		
			var k = i+1;
			
			str1 = str1+k+"\t";
		
			str=str+"["+k+"]\t";
			
			phy=phy+lbls[i]+"\t";
		
			for(var j = 0; j < tot; j++){
			
				var tmp = pw[i][j];
				
				var trs = tmp.toPrecision(5);
				
				phy=phy+trs+"\t";
				
				if(j < i){
			
					str=str+trs+"\t";
					
				}
				
			}
		
			str=str+"\n";
			
			phy=phy+"\n";
		
		}
		
		str1=str1+"]\n";
		
		if(format == 1){
		
			var dis = nmss+str1+str;
			
		}
		
		else if(format == 2){
		
			var dis = phy;
			
		}
	
		var y = document.createElement("TEXTAREA");
		
		var u = document.createTextNode(dis);
    
    	y.appendChild(u);
   		
    	y.setAttribute("type", "text");
    	
    	y.setAttribute("rows", "40");
    	
    	y.setAttribute("cols", "120");
    	
    	document.body.appendChild(y);
	
	}
	
	/**********************************************************************
	* The function treeFile will present the Newick formatted tree file 
	**********************************************************************/
  	
  	function treeFile(topology) {
		
		var x = document.createElement("TEXTAREA");
		
		var t = document.createTextNode(topology);
    
    	x.appendChild(t);
   		
    	x.setAttribute("type", "text");
    	
    	x.setAttribute("rows", "20");
    	
    	x.setAttribute("cols", "100");
    	
    	document.body.appendChild(x);
    	
	}
	
	/**********************************************************************
	* Constructs the rectangular and circular tree
	**********************************************************************/
  
	d3.phylogram = {}
	
  	d3.phylogram.rightAngleDiagonal = function() {
  	
		var projection = function(d) { return [d.y, d.x]; }
    
    	var path = function(pathData) {
    	
     	return "M" + pathData[0] + ' ' + pathData[1] + " " + pathData[2];
     	
    }
    
    function diagonal(diagonalPath, i) {
    
      		var source = diagonalPath.source,
      		
          	target = diagonalPath.target,
          	
          	midpointX = (source.x + target.x) / 2,
          	
          	midpointY = (source.y + target.y) / 2,
          	
          	pathData = [source, {x: target.x, y: source.y}, target];
          	
			pathData = pathData.map(projection);
			
     	 	return path(pathData)
     	 	
    	}
    
    	diagonal.projection = function(x) {
    	
			if (!arguments.length) return projection;
			
			projection = x;
			
			return diagonal;
     	 
    	};
    
    	diagonal.path = function(x) {
    	
			if (!arguments.length) return path;
			
			path = x;
			
			return diagonal;
      	
    	};
    
    	return diagonal;
  	}
  
	d3.phylogram.radialRightAngleDiagonal = function() {
	
    	return d3.phylogram.rightAngleDiagonal()
    	
      	.path(function(pathData) {
      	
       	 var src = pathData[0],
       	 
           	 mid = pathData[1],
           	 
            	dst = pathData[2],
            	
            	radius = Math.sqrt(src[0]*src[0] + src[1]*src[1]),
            	
            	srcAngle = d3.phylogram.coordinateToAngle(src, radius),
            	
           	 	midAngle = d3.phylogram.coordinateToAngle(mid, radius),
           	 	
            	clockwise = Math.abs(midAngle - srcAngle) > Math.PI ? midAngle <= srcAngle : midAngle > srcAngle,
            	
            	rotation = 0,
            	
            	largeArc = 0,
            	
            	sweep = clockwise ? 0 : 1;
            	
          	return 'M' + src + ' ' +
          	
          	"A" + [radius,radius] + ' ' + rotation + ' ' + largeArc+','+sweep + ' ' + mid +
          	'L' + dst; 
          	
     	 })
     	 
      	.projection(function(d) {
      	
        	var r = d.y, a = (d.x - 90) / 180 * Math.PI;
        	
        	return [r * Math.cos(a), r * Math.sin(a)];
        	
      	})
  }
  
  // Convert XY and radius to angle of a circle centered at 0,0
  
  d3.phylogram.coordinateToAngle = function(coord, radius) {
  
    	var wholeAngle = 2 * Math.PI,
    	
        quarterAngle = wholeAngle / 4
    
    	var coordQuad = coord[0] >= 0 ? (coord[1] >= 0 ? 1 : 2) : (coord[1] >= 0 ? 4 : 3),
    	
        coordBaseAngle = Math.abs(Math.asin(coord[1] / radius))
    
    	// Since this is just based on the angle of the right triangle formed
   	 	// by the coordinate and the origin, each quad will have different 
    	// offsets
		
   	 switch (coordQuad) {
   	 
      	case 1:
      	
        	coordAngle = quarterAngle - coordBaseAngle
        	
       	 break
       	 
      	case 2:
      	
        	coordAngle = quarterAngle + coordBaseAngle
        	
        	break
        	
      	case 3:
      	
        	coordAngle = 2*quarterAngle + quarterAngle - coordBaseAngle
        	
       	 break
       	 
      	case 4:
      	
       	 coordAngle = 3*quarterAngle + coordBaseAngle
		
   	 }
	 
    	return coordAngle
  
  }
  
  	d3.phylogram.styleTreeNodes = function(vis) {
  	
    	vis.selectAll('g.root.node')
    	
      	.append('svg:circle')
      	
        .attr("r", 4.5)
        
        .attr('fill', 'Yellow')
        
        .attr('stroke', 'Black')
        
        .attr('stroke-width', '2px');
        
  	}
  
  	function scaleBranchLengths(nodes, w) {
  	
    // Visit all nodes and adjust y pos width distance metric
    
    var visitPreOrder = function(root, callback) 
    {
      callback(root)
      
      if (root.children) {
      
        for (var i = root.children.length - 1; i >= 0; i--){
        
			visitPreOrder(root.children[i], callback)
			
        	};
        	
      	}
      	
    }
   		visitPreOrder(nodes[0], function(node) {
   		
      	node.rootDist = (node.parent ? node.parent.rootDist : 0) + (node.length || 0)
      	
    })
    
    	var rootDists = nodes.map(function(n) { return n.rootDist; });
    	
    	var yscale = d3.scale.linear()
    	
      	.domain([0, d3.max(rootDists)])
      	
      	.range([0, w]);
      	
    	visitPreOrder(nodes[0], function(node) {
    	
      	node.y = yscale(node.rootDist)
      	
    	})
    	
    return yscale
    
  	}
  
	d3.phylogram.build = function(selector, nodes, options) {
	
   	 options = options || {}
   	 
    	var w = options.width || d3.select(selector).style('width') || d3.select(selector).attr('width'),
    	
       	 h = options.height || d3.select(selector).style('height') || d3.select(selector).attr('height'),
       	 
       	 w = parseInt(w),
       	 
       	 h = parseInt(h);
       	 
    	var tree = options.tree || d3.layout.cluster()
    	
      	.size([h, w])
      	
      	.sort(function(node) { return node.children ? node.children.length : -1; })
      	
      	.children(options.children || function(node) {
      	
       	 return node.branchset
       
      	});
      	
		var diagonal = options.diagonal || d3.phylogram.rightAngleDiagonal();
		
		var vis = options.vis || d3.select(selector).append("svg:svg")
		
        	.attr("width", w + 300)
        	
        	.attr("height", h + 30)
        	
      	.append("svg:g")
      	
        	.attr("transform", "translate(20, 20)");
        	
    	var nodes = tree(nodes);
    
    	if (options.skipBranchLengthScaling) {
    	
      	var yscale = d3.scale.linear()
      	
        	.domain([0, w])
        	
        	.range([0, w]);
        	
    	} else {
    	
      	var yscale = scaleBranchLengths(nodes, w)
      	
    	}
    
    var link = vis.selectAll("path.link")
    
        .data(tree.links(nodes))
        
      .enter().append("svg:path")
      
        .attr("class", "link")
        
        .attr("d", diagonal)
        
        .attr("fill", "none")
        
        .attr("stroke", "DodgerBlue")
        
        .attr("stroke-width", "2px");
        
    var node = vis.selectAll("g.node")
    
        .data(nodes)
        
      .enter().append("svg:g")
      
        .attr("class", function(n) {
        
          if (n.children) {
          
            if (n.depth == 0) {
            
              return "root node"
              
            } else {
            
              return "inner node"
              
            }
            
          } else {
          
            return "leaf node"
            
          }
          
        })
        
        .attr("transform", function(d) { return "translate(" + d.y + "," + d.x + ")"; }) //node
      
    d3.phylogram.styleTreeNodes(vis)
    
    	if (!options.skipLabels) {
    	
      		vis.selectAll('g.inner.node')
      		
        	.append("svg:text")
        	
          	.attr("dx", -6)
          	
          	.attr("dy", -6)
          	
          	.attr("text-anchor", 'end')
          	
          	.attr('font-size', '8px')
          	
          	.attr('fill', '#ccc')
          	
          	.text(function(d) { return d.name; });

     		 vis.selectAll('g.leaf.node').append("svg:text")
     		 
        	.attr("dx", 8)
        	
        	.attr("dy", 3)
        	
        	.attr("text-anchor", "start")
        	
        	.attr('font-family', 'Times, Times New Roman')
        	
        	.attr('font-size', '20px')
        	
        	.attr('font-style', 'italic')
        	
        	.attr('fill', 'red')
        	
        	.text(function(d) { return d.name; });
    	}
    
    	return {tree: tree, vis: vis}
	}
  
	d3.phylogram.buildRadial = function(selector, nodes, options) {
	
    	options = options || {}
    	
    	var w = options.width || d3.select(selector).style('width') || d3.select(selector).attr('width'),
    	
		r = w / 2,
		
		labelWidth = options.skipLabels ? 10 : options.labelWidth || 120;
    
		var vis = d3.select(selector).append("svg:svg")
		
       	.attr("width", r * 2)
       	
        .attr("height", r * 2) 
        
      	.append("svg:g")
      	
        .attr("transform", "translate(" + r + "," + r + ")");
        
   		var tree = d3.layout.tree()
   		
      	.size([360, r - labelWidth])
      	
     	.sort(function(node) { return node.children ? node.children.length : -1; })
     	
      	.children(options.children || function(node) {
      	
        	return node.branchset
      	})
      	
      	.separation(function(a, b) { return (a.parent == b.parent ? 1 : 2) / a.depth; }); 
    
    	var phylogram = d3.phylogram.build(selector, nodes, {
    	
      	vis: vis,
      	
      	tree: tree,
      	
      	skipBranchLengthScaling: true,
      	
      	skipTicks: true,
      	
      	skipLabels: options.skipLabels,
      	
      	diagonal: d3.phylogram.radialRightAngleDiagonal()
      	
    	})
    	vis.selectAll('g.node')
    	
      	.attr("transform", function(d) { return "rotate(" + (d.x - 90) + ")translate(" + d.y + ")"; })
    
    	if (!options.skipLabels) {
    	
     	 vis.selectAll('g.leaf.node text')
     	 
        	.attr("dx", function(d) { return d.x < 180 ? 8 : -8; })
        	
        	.attr("dy", ".31em")
        	
        	.attr("text-anchor", function(d) { return d.x < 180 ? "start" : "end"; })
        	
        	.attr("transform", function(d) { return d.x < 180 ? null : "rotate(180)"; })
        	
        	.attr('font-family', 'Helvetica Neue, Helvetica, sans-serif')
        	
        	.attr('font-size', '10px')
        	
        	.attr('fill', 'black')
        	
        	.text(function(d) { return d.data.name; });

      	vis.selectAll('g.inner.node text')
      	
        	.attr("dx", function(d) { return d.x < 180 ? -6 : 6; })
        	
        	.attr("text-anchor", function(d) { return d.x < 180 ? "end" : "start"; })
        	
        	.attr("transform", function(d) { return d.x < 180 ? null : "rotate(180)"; });
    	}
    
    	return {tree: tree, vis: vis}
		
  	}
  
    </script>
    
	<style type="text/css" media="screen">
    
		body { font-family: "Times", Times New Roman; }
		
		td { vertical-align: center; }
    
	</style>
  	
	</head>
  	
	<body>
  
  	<style type="text/css" media="screen">
    
		body { font-family: "Times", Times New Roman; }
		
		td { vertical-align: center; }
    
	</style>
  
  	<h2>&nbsp&nbsp&nbsp&nbsp&nbsp&nbspPhylogenetic tree</h2>
  	
  	<h4>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspConstruct Tree</h4>
  	
  	&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp  <input type="radio" name="colors1" id="black" checked>UPGMA tree<br>
  	
	&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp  <input type="radio" name="colors1" id="brown">Neighbour-Joining tree (Unrooted)<br>
  	
  	<h4>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspDrawing options</h4>
  	
  	&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp  <input type="radio" name="colors2" id="red" checked>Rectangular tree<br>
  	
	&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp  <input type="radio" name="colors2" id="blue">Radial tree<br>
  	
	<h4>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp Data</h4>
  	
	&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp  <input type="radio" name="colors3" id="green">Newick tree format<br>
	
	&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp  <input type="radio" name="colors3" id="yellow">Pair-wise diversity - MEGA<br>
	
	&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp  <input type="radio" name="colors3" id="orange">Pair-wise diversity - PHYLIP<br>
	
	<h4>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspEnter the genome size (base pairs)</h4>
	
	&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp  <input type="text" id="myText" value="2875001522">
  	
  	<p>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspRead VCF file</p>
  	
  	&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp  <input type="file" onchange='readText(this,document.getElementById("black").checked,document.getElementById("brown").checked,document.getElementById("red").checked,document.getElementById("blue").checked,document.getElementById("green").checked,document.getElementById("yellow").checked,document.getElementById("orange").checked,document.getElementById("myText").value)'/>
  	
	&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp  <button onclick=goBack()>REDRAW OR CLEAR SCREEN</button>
  	
	&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp  <p id="demo"></p>

	
    <table>
    
	<tr>

	    <td>
          
			<div id='phylogram'></div>
        
		</td>
        	
      </tr>
    
	</table>
  
  </body>

 </html>
